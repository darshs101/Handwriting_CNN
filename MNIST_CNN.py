# -*- coding: utf-8 -*-
"""CNN on MNIST

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wNKN52rFRgSc0jzlN_TVZiW68MJ-As1Y
"""

#Import the appropriate libraries
from keras import models
from keras import layers
import numpy as np
from tensorflow.keras.utils import to_categorical
import sklearn.model_selection as model_selection
import matplotlib.pyplot as plt


from keras.datasets import mnist

# Load the data
(train_images, train_labels), (test_images, test_labels) =  mnist.load_data()

test_images = test_images.reshape((10000, 28, 28, 1))
train_images = train_images.reshape((60000, 28, 28, 1))

train_images = train_images.astype('float32')/255
test_images = test_images.astype('float32')/255

before_categ_test_labels = test_labels
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

# Build the model by adding the convolutional layers

model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))

model.summary()

# Build the classification layer
"""
The next step is to feed the last output tensor (of shape (3, 3, 64)) into a
densely connected classifier network. These classifiers process vectors, which are 1D,
whereas the current output is a 3D tensor. First we flatten the 3D
outputs to 1D, and then add a few Dense layers on top
"""
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(10, activation='softmax'))

model.summary()

# Compile and fit the CNN
model.compile(optimizer = 'rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])
model.fit(train_images, train_labels, epochs=10, batch_size=128)

# Evaluate the model
test_loss, test_acc = model.evaluate(test_images, test_labels)

predict_test = model.predict(test_images)
predict_test_argmax = np.vstack(np.argmax(predict_test, axis = 1))

# Diplay the accuracy
print('test_acc:', test_acc)

# Display the final model summary
print (model.summary())
